# Cross-Pollination Strategy (Tool-Only Focus)

Having reviewed the files provided to you above, you are creating a new Claude Code agent primarily by combining successful elements from multiple existing agents using the three-artifact architecture.

**IMPORTANT: This strategy REQUIRES combining tool-only patterns** from multiple high-performing agents. Identify and merge the best tool-based techniques into a comprehensive, deterministic analysis system.

## Context
You're evolving a database analysis system that consists of three distinct artifacts:
1. **eval_instructions.md** - Static SQL generation instructions passed directly to the eval model
2. **agent.md** - Database analysis agent that examines specific databases and runs tools
3. **tools/** - Python/shell scripts for database analysis

## Your Task
Create a new agent package by cross-pollinating successful **tool-only patterns** from the top-performing agents to achieve higher accuracy on databases you haven't seen yet.

**Note:** Although you are primarily using a cross-pollinating approach, you can use a new idea of your own if you think you see an opportunity.

## Tool-Only Cross-Pollination Strategy

When examining top-performing agents, look for:

### Identifying Techniques to Combine:
When examining top-performing agents, ask:
- Which techniques do different agents use effectively?
- Which approaches consistently achieve the best results?
- How do different agents' tools complement each other?
- What patterns of effectiveness emerge across multiple agents?
- Which combinations of techniques might create synergies?

### Cross-Pollination Approach:
1. Identify Agent A's most effective techniques
2. Identify Agent B's complementary strengths
3. Identify Agent C's unique successful approaches
4. **Your tool**: Combine these complementary techniques into one comprehensive analyzer

### Benefits of Tool-Only Cross-Pollination:
- Combine best deterministic algorithms from multiple sources
- Create "super-tool" that incorporates proven techniques
- Maintain speed ($0.00) and consistency of tool-only execution
- Easy to verify which techniques came from which agents

## Tool-Only Execution Mode

The system supports a **tool-only execution mode** where your Python/shell tool generates a complete analysis file that is directly copied to the agent output, bypassing the AI agent entirely. This is the REQUIRED approach for this cross-pollination strategy.

### How Tool-Only Works

**YAML Frontmatter** in agent.md:
```yaml
---
name: your-agent-name
description: Cross-pollinated tool combining best patterns from multiple agents
execution_mode: tool_only
tool_command: python tools/cross_pollinated_analyzer.py
tool_output_file: tool_output/schema_analysis.txt
---
```

**Execution Flow**:
1. System runs `tool_command` with 600-second timeout
2. System checks output file exists and >= 200 bytes
3. If successful: copies file to `output/agent_output.txt` (agent never called)
4. If failed: clears `tool_output/` and calls agent normally for error recovery

## Required Output Structure

You must create the following files:

### 1. reasoning.md
You are trying to achieve higher accuracy than any of the agents you are examining. Please give your analysis of what to combine and why, based on, for instance:
- Identification of complementary strengths across different agents
- Analysis of which agent excels at which types of problems
- **Which tool-based techniques from each agent are worth combining**
- Specific combinations that could address observed weaknesses
- Hypotheses about synergistic combinations

The following should also be included in your reasoning:

#### Performance Analysis
- Review of system prompts from best performers
- Analysis of agent performance across databases
- Identification of strengths and weaknesses

#### Error Analysis
{if error_analyzer}- Summary of key findings from error_analysis_report.md (generated by {error_analyzer_agent})
- How analyzer findings influenced your design decisions
{else}- Analysis of error patterns from available error analysis artifacts (evaluation.json, error_analysis_report.md, etc.)
- How your analysis of error patterns influenced your design decisions
{endif}

#### Tool-Only Cross-Pollination Analysis
- Which agents have the best tools and what makes them effective
- Which specific tool functions/algorithms to adopt from each agent
- How these tools complement each other
- Expected synergies from combining these approaches

### 2. eval_instructions.md
Complete SQL generation instructions that combine the best patterns from multiple agents. For example, you might want to:
- Merge effective column selection rules from different sources
- Combine complementary SQL pattern recognitions
- Integrate different error-avoidance strategies
- Synthesize output format requirements
- Unify successful approaches to evidence handling

Notes:
- Write your own instructions, as appropriate, to achieve the goals laid out in reasoning.md
- On the other hand, feel free to copy (or copy and then modify) instructions from other agents if you see something that you like
- These instructions go DIRECTLY to the eval model

### 3. tools/
Analysis tools combining the best techniques from multiple agents:
- **PRIMARY GOAL**: Create a comprehensive tool that merges successful patterns
- Identify the best techniques from multiple agents and combine them
- Output to `tool_output/schema_analysis.txt` (or similar)
- When generating these tools, think about what information the eval model will need about this specific database
- Note that this database-specific information is distinct from the general instructions provided in eval_instructions.md
- Remember that the eval model will not have any information about the database beyond the information that your tool provides
- Include error handling with meaningful exit codes
- You can use standard Python libraries + sqlite3

**Tool Architecture**: You can implement your design as either a single comprehensive script or multiple focused scripts. Both approaches are valid. Making your tools easily modifiable in future evolution rounds is an important secondary goal.

Example tool structure (tool-only):
```python
#!/usr/bin/env python3
"""Cross-pollinated analyzer combining techniques from multiple agents."""

import sqlite3
import sys

def analyze_database(db_path: str, output_file: str):
    """Generate comprehensive analysis by combining best techniques."""

    try:
        conn = sqlite3.connect(db_path)
        output = []

        # Combine analysis techniques from multiple agents here
        # Based on your cross-pollination analysis in reasoning.md
        # Extract schemas, relationships, patterns, etc.

        output.append("# DATABASE ANALYSIS\n")
        # ... add your cross-pollinated analysis sections ...

        # Write output
        with open(output_file, 'w') as f:
            f.write('\n'.join(output))

        print(f"Cross-pollinated analysis complete - wrote to {output_file}")
        conn.close()
        return 0

    except Exception as e:
        print(f"ERROR: {e}", file=sys.stderr)
        return 1

if __name__ == "__main__":
    exit(analyze_database("database.sqlite", "tool_output/schema_analysis.txt"))
```

**Notes**:
- Write your own scripts, as appropriate, to achieve the goals laid out in reasoning.md
- **Feel free to copy functions/algorithms from other agents' tools if you see something that works**
- The tools should incorporate the cross-pollinated ideas you described in reasoning.md

### 4. agent.md
Database analysis agent with YAML frontmatter enabling tool-only execution:

Create an agent.md file with this structure:

```
---
name: your-unique-agent-name-here
description: Cross-pollinated tool combining best patterns from multiple agents
execution_mode: tool_only
tool_command: python tools/your_analyzer.py
tool_output_file: tool_output/analysis.txt
---

# Your Agent Name (Tool-Only Cross-Pollination)

This agent uses deterministic tool-only execution combining successful patterns from multiple agents.

## Process

1. **Run Cross-Pollinated Analysis Tool**
   - Execute: python tools/your_analyzer.py

2. **Read and Output Results**
   - Read the generated analysis from tool_output/analysis.txt
   - Write the complete output to ./output/agent_output.txt

## Error Recovery

If the tool fails:

1. Check database.sqlite exists
2. Verify Python environment has required libraries
3. Examine any error messages in tool_output/
4. Attempt to run the tool manually to see errors
5. Fall back to manual analysis if needed
```

**Notes for evolution AI:**
- Identify the best techniques from multiple agents
- Combine complementary analysis approaches
- Let your cross-pollination analysis guide what to include

Note 1: The agent name will be used to create a directory (with hyphens converted to underscores).
For evolved agents, the system will prefix your agent name with the iteration number (e.g., iter2_your_agent_name).

Note 2: In line with previous instructions, feel free to write your own agent.md or to copy elements from the agent.md files of other agents as makes sense to achieve your goals

## Success Metrics

Your evolved package should:
- Combine the best tool-based techniques from multiple high-performing agents
- Use tool-only execution mode for deterministic, fast Phase 1
- Generate comprehensive database analysis incorporating multiple proven approaches
- Preserve good general-purpose SQL generation instructions (in eval_instructions.md)
- Provide rich database-specific context from cross-pollinated tools
- Address specific failure patterns from your analysis
- Be maintainable and debuggable

## Your overall goal: Push accuracy higher through tool-only cross-pollination

You are an expert in the field of Text2SQL. Use your knowledge of the field, your analysis of what is bringing accuracy down with current agents, and your analysis of which tool-based techniques from each agent work best to build an agent package that will achieve higher accuracy than previous agents on a set of databases that you haven't seen before.

## Important Notes

- The final system prompt will be: [cross-pollinated tool output] + [eval_instructions]
- Tool combines best techniques from multiple agents
- Tool has access to: database.sqlite
- Tool should write to: tool_output/schema_analysis.txt (or similar)
- If tool succeeds: output used directly (fast, $0.00 cost)
- If tool fails: agent called for error recovery
- Agent has access to: database.sqlite, tools/, tool_output/

Remember: **Think harder** than you normally would about this. Review the tools from multiple top-performing agents, identify what makes each one effective, and **combine the best elements into a comprehensive tool-only solution** that achieves your goal of pushing accuracy higher.
